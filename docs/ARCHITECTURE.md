# zBricks Library Architecture

This document describes the internal architecture and design principles of the zBricks library.

---

## Core Philosophy

zBricks is designed around the principle of **convention over configuration** with **intelligent defaults**. The library should make common web development tasks simple while remaining flexible for advanced use cases.

## Package Structure

```
src/zbricks/
├── __init__.py          # Main package exports
├── _version.py          # Version info (generated by hatch-vcs)
├── py.typed            # Type checking marker
└── core/               # Core functionality
    ├── __init__.py
    ├── middleware.py    # Custom middleware
    ├── router.py        # Default routing utilities  
    ├── settings.py      # Configuration management
    ├── templating.py    # Smart template engine
    ├── static/          # Default static files
    └── templates/       # Default templates
        └── base.html    # Base template for inheritance
```

## Core Components

### Templating System (`core/templating.py`)

The templating system is the heart of zBricks, providing intelligent template discovery and inheritance:

**Key Features:**
- **Automatic template discovery**: Uses Python's inspection to find templates relative to the calling code
- **Fallback hierarchy**: Project templates → zBricks core templates
- **Template inheritance**: Built-in base templates with block system
- **Context injection**: Automatic request context and user-defined context

**How it works:**
1. `render_template()` uses stack inspection to find the caller's location
2. Searches for templates in `caller_directory/templates/`
3. Falls back to `zbricks/core/templates/` for base templates
4. Jinja2 environment handles inheritance and rendering

### Middleware System (`core/middleware.py`)

**StaticFallbackMiddleware:**
- Serves static files from project-specific directories first
- Falls back to zBricks core static files
- Handles 404s gracefully for missing static assets

### Settings Management (`core/settings.py`)

- Environment-based configuration
- Security validation (e.g., production secret key checks)
- Extensible for project-specific settings

### Router Utilities (`core/router.py`)

- Default route handlers for common patterns
- Integration with templating system
- Base for building custom routing logic

## Design Patterns

### Template Discovery

The template discovery mechanism uses Python's `inspect` module to determine the calling context:

```python
def get_template_environment_for_caller():
    frame = inspect.currentframe()
    if frame and frame.f_back and frame.f_back.f_back:
        caller_frame = frame.f_back.f_back
        caller_file = Path(caller_frame.f_globals.get('__file__', ''))
        # Search for templates relative to caller
```

This allows examples and projects to have their own templates while automatically inheriting from zBricks base templates.

### Fallback Strategy

All resource loading (templates, static files) follows a consistent fallback pattern:

1. **Project-specific resources** (highest priority)
2. **zBricks core resources** (fallback)
3. **404/Error handling** (if not found)

### Context Management

Template rendering automatically injects:
- `request` object for accessing HTTP context
- User-provided context variables
- Potential future: user session, CSRF tokens, etc.

## Extension Points

### Custom Middleware

Projects can extend the middleware stack:

```python
from starlette.middleware import Middleware
from zbricks.core.middleware import StaticFallbackMiddleware

middleware = [
    Middleware(StaticFallbackMiddleware),
    # Add your custom middleware here
]
```

### Template Customization

Projects can:
- Override any zBricks template by creating their own version
- Extend base templates using Jinja2 inheritance
- Add custom template filters and functions

### Settings Extension

Extend the base settings class:

```python
from zbricks.core.settings import Settings

class MyProjectSettings(Settings):
    DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///app.db")
```

## Future Enhancements

### Planned Features

1. **Database Integration**: SQLAlchemy/Tortoise ORM support
2. **Authentication**: Built-in auth middleware and templates
3. **Form Handling**: Form validation and rendering utilities
4. **API Utilities**: JSON response helpers, API versioning
5. **Deployment Tools**: Docker, WSGI/ASGI deployment helpers

### Architecture Considerations

- **Plugin System**: Allow third-party extensions
- **Configuration Discovery**: Automatic project config detection
- **Development Tools**: Debug toolbar, auto-reload enhancements
- **Performance**: Template caching, static file optimization

---

## Contributing to the Architecture

When adding new features:

1. **Follow the fallback pattern** for resource discovery
2. **Maintain backward compatibility** 
3. **Use type hints** throughout
4. **Add comprehensive tests** for new components
5. **Document extension points** for users

The architecture should remain simple and predictable while providing powerful capabilities for web application development.
