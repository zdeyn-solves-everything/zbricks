"""
Serve the documentation live from source using Starlette and Jinja2.

Usage:
    python -m zbricks.docs.serve [--host 0.0.0.0] [--port 9001] [--src /path/to/docs/content] \
        [--theme /path/to/theme] [--reload]
"""
import argparse
import logging
import os
import sys
from importlib import import_module
from pathlib import Path

import markdown_it
import uvicorn
import yaml
from jinja2 import ChoiceLoader, FileSystemLoader
from starlette.applications import Starlette
from starlette.responses import Response
from starlette.routing import Route
from starlette.templating import Jinja2Templates

from .docs_signals import (
    ContentDiscovered,
    ContentLoaded,
    ServerStarted,
    SiteConfigLoaded,
    ThemeResolved,
)

# Signal subscriptions must use decorator form: @Signal.subscribe()

site_config_cache: dict = {}
content_cache = {}
theme_cache = {}

logging.basicConfig(
    level=logging.INFO,
    format="[%(levelname)s] %(message)s"
)
logger = logging.getLogger("zbricks.docs.serve")


@SiteConfigLoaded.subscribe()
def on_site_config_loaded(signal, payload):
    site_config_cache.clear()
    site_config_cache.update(signal.config)


@ContentDiscovered.subscribe()
def on_content_discovered(signal, payload):
    content_cache["files"] = signal.files


@ContentLoaded.subscribe()
def on_content_loaded(signal, payload):
    content_cache[signal.slug] = {"meta": signal.meta, "body": signal.body}


@ThemeResolved.subscribe()
def on_theme_resolved(signal, payload):
    theme_cache["dirs"] = signal.theme_dirs


@ServerStarted.subscribe()
def on_server_started(signal, payload):
    logger.info(f"[docs] Server started at http://{signal.host}:{signal.port}")


def load_site_yaml(site_yaml_path):
    with open(site_yaml_path, encoding="utf-8") as f:
        config = yaml.safe_load(f)
    SiteConfigLoaded(path=site_yaml_path, config=config).emit()
    return config


def discover_content(content_dir):
    files = []
    for fname in os.listdir(content_dir):
        if fname.endswith(".md"):
            files.append(fname)
    ContentDiscovered(content_dir=content_dir, files=files).emit()
    return files


def load_content_file(content_dir, doc_name):
    doc_path = os.path.join(content_dir, f"{doc_name}.md")
    if os.path.exists(doc_path):
        with open(doc_path, encoding="utf-8") as f:
            content = f.read()
        if content.startswith("---"):
            parts = content.split("---", 2)
            if len(parts) >= 3:
                meta = yaml.safe_load(parts[1])
                body = parts[2].lstrip()
            else:
                meta = {}
                body = content
        else:
            meta = {}
            body = content
        ContentLoaded(slug=doc_name, meta=meta, body=body).emit()
        return meta, body
    return {}, ""


def get_theme_dirs(site_def, theme_dir=None):
    """Return a list of theme directories in order of precedence from site.yaml and test args."""
    theme_dirs = []
    if theme_dir:
        theme_dirs.append(os.path.abspath(theme_dir))
    theme_name = site_def.get("theme")
    base_dir = os.path.dirname(__file__)
    if theme_name:
        custom_theme = os.path.abspath(os.path.join(base_dir, "../themes", theme_name))
        if os.path.isdir(custom_theme):
            theme_dirs.append(custom_theme)
    user_themes = os.path.abspath(os.path.join(base_dir, "../themes"))
    if os.path.isdir(user_themes):
        theme_dirs.append(user_themes)
    default_theme = os.path.abspath(os.path.join(base_dir, "../themes/_default"))
    if os.path.isdir(default_theme):
        theme_dirs.append(default_theme)
    ThemeResolved(theme_dirs=theme_dirs).emit()
    return theme_dirs


def generate_api_doc(module):
    """Generate a simple API doc for a module (placeholder, can be improved).
    Uses docstrings and dir()."""
    lines = [f"# API Reference: {module.__name__}\n"]
    if module.__doc__:
        lines.append(module.__doc__ + "\n")
    for name in dir(module):
        if name.startswith("_"):
            continue
        obj = getattr(module, name)
        doc = getattr(obj, "__doc__", None)
        lines.append(f"## {name}\n")
        if doc:
            lines.append(doc + "\n")
    return "\n".join(lines)


def build_site_docs(site_def, content_dir):
    """
    Build docs structure from site.yaml, loading markdown files and handling autogenerated entries.
    Returns a dict of slug -> doc dicts.
    """
    docs = {}

    def process_nav(nav_items, parent_slug=None):
        for item in nav_items:
            slug = item.get("slug")
            doc_entry = {"meta": {}, "body": "", "slug": slug, "title": item.get("title", slug)}
            if item.get("autogenerated") and item.get("module"):
                # Autogenerated API docs
                module = import_module(item["module"])
                doc_entry["body"] = generate_api_doc(module)
                doc_entry["meta"]["autogenerated"] = True
            elif "doc" in item:
                doc_path = os.path.join(content_dir, f"{item['doc']}.md")
                if os.path.exists(doc_path):
                    with open(doc_path, encoding="utf-8") as f:
                        content = f.read()
                    if content.startswith("---"):
                        parts = content.split("---", 2)
                        if len(parts) >= 3:
                            meta = yaml.safe_load(parts[1])
                            body = parts[2].lstrip()
                        else:
                            meta = {}
                            body = content
                    else:
                        meta = {}
                        body = content
                    doc_entry["meta"] = meta
                    doc_entry["body"] = body
            docs[slug] = doc_entry
            # Recursively process children
            if "children" in item:
                process_nav(item["children"], parent_slug=slug)

    process_nav(site_def["nav"])
    return docs


def crawl_docs(src_dir):
    """Crawl the docs source directory for Markdown/YAML files and return a docs index."""
    docs = []
    src_dir = Path(src_dir)
    for root, _, files in os.walk(src_dir):
        root_path = Path(root)
        for fname in files:
            if fname.endswith(".md"):
                path = root_path / fname
                rel_path = path.relative_to(src_dir)
                with open(path, encoding="utf-8") as f:
                    content = f.read()
                # Parse YAML frontmatter if present
                if content.startswith("---"):
                    parts = content.split("---", 2)
                    if len(parts) >= 3:
                        meta = yaml.safe_load(parts[1])
                        body = parts[2].lstrip()
                    else:
                        meta = {}
                        body = content
                else:
                    meta = {}
                    body = content
                # Prefer explicit slug, else use rel_path without .md
                rel_str = str(rel_path)
                slug = meta.get("slug") or rel_str[:-3] if rel_str.endswith(".md") else rel_str
                docs.append({
                    "meta": meta,
                    "body": body,
                    "slug": slug,
                    "title": meta.get("title") or path.stem
                })
    return {doc["slug"]: doc for doc in docs}


def create_app(src_dir, theme_dir=None, site_yaml_path=None):
    if site_yaml_path is None:
        site_yaml_path = os.path.join(os.path.dirname(__file__), "site.yaml")
    # Use the provided src_dir for content_dir
    content_dir = src_dir
    site_def = load_site_yaml(site_yaml_path)
    docs = build_site_docs(site_def, content_dir)
    theme_dirs = get_theme_dirs(site_def, theme_dir=theme_dir)
    loaders = [FileSystemLoader(d) for d in theme_dirs]
    templates = Jinja2Templates(directory=theme_dirs[0])
    templates.env.loader = ChoiceLoader(loaders)
    md = markdown_it.MarkdownIt("commonmark", {"html": True})

    async def index(request):
        # List all docs from site.yaml nav
        doc_list = [
            {"slug": k, "title": v["title"]}
            for k, v in docs.items()
        ]
        return templates.TemplateResponse(
            request, "index.html", {"docs": doc_list}
        )

    async def doc_page(request):
        slug = request.path_params["slug"]
        if slug in docs:
            doc = docs[slug]
            # Always render markdown for doc pages
            html = md.render(doc["body"])
            return templates.TemplateResponse(
                request,
                "doc.html",
                {
                    "doc": doc,
                    "meta": doc["meta"],
                    "content": html,
                    "slug": slug,
                },
            )
        return Response("Not found", status_code=404)

    routes = [
        Route("/", index),
        Route("/{slug}", doc_page),
    ]
    app = Starlette(routes=routes)
    return app


def watch_and_reload(app, src_dir):
    try:
        from watchdog.events import FileSystemEventHandler
        from watchdog.observers import Observer
    except ImportError:
        sys.stderr.write(
            "watchdog is required for --reload. Install with 'pip install watchdog'\n"
        )
        sys.exit(1)
    class ReloadHandler(FileSystemEventHandler):
        def on_any_event(self, event):
            app.state.docs = crawl_docs(src_dir)
            sys.stdout.write("[docs] Reloaded docs context\n")
    observer = Observer()
    observer.schedule(ReloadHandler(), src_dir, recursive=True)
    observer.start()
    sys.stdout.write(f"[docs] Watching {src_dir} for changes...\n")
    return observer


def main():
    parser = argparse.ArgumentParser(description="Serve docs live from source.")
    parser.add_argument(
        "--host",
        default="0.0.0.0",
        help="Host to bind (default: 0.0.0.0)"
    )
    parser.add_argument(
        "--port",
        type=int,
        default=9001,
        help="Port to bind (default: 9001)"
    )
    parser.add_argument(
        "--src",
        default=None,
        help="Docs source directory (default: ./src/docs/content)"
    )
    parser.add_argument(
        "--theme",
        default=None,
        help="Theme directory (default: ./src/docs/theme)"
    )
    parser.add_argument(
        "--reload",
        action="store_true",
        help="Watch docs source and reload on change"
    )
    args = parser.parse_args()
    src_dir = args.src or os.path.abspath(
        os.path.join(os.path.dirname(__file__), "../../docs/content")
    )
    theme_dir = args.theme or os.path.abspath(
        os.path.join(os.path.dirname(__file__), "../../docs/theme")
    )
    if not os.path.isdir(src_dir):
        sys.stderr.write(f"Could not find docs source directory: {src_dir}\n")
        sys.exit(1)
    app = create_app(src_dir, theme_dir)
    observer = None
    if args.reload:
        observer = watch_and_reload(app, src_dir)
    try:
        uvicorn.run(app, host=args.host, port=args.port, log_level="info")
    finally:
        if observer:
            observer.stop()
            observer.join()


if __name__ == "__main__":
    main()
